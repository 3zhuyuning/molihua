# MySQL的索引

[CodingLabs - MySQL索引背后的数据结构及算法原理](https://blog.codinglabs.org/articles/theory-of-mysql-index.html)

# 一、搜索树

## 1、二叉搜索树

二叉搜索树（Binary Search Tree，简称BST）是一种二叉树数据结构，具有以下性质：

1. **有序性：** 对于二叉搜索树中的每个节点，其左子树中的所有节点的值都小于该节点的值，而右子树中的所有节点的值都大于该节点的值。
2. **递归性：** 二叉搜索树的左子树和右子树也是二叉搜索树。

这两个性质保证了在二叉搜索树中进行查找、插入和删除等操作时的高效性。由于有序性，可以利用二分查找的思想进行快速搜索。

以下是一个简单的二叉搜索树的示例：

```markdown
      5
     / \
    3   8
   / \ / \
  2  4 6  9
```

在这个示例中，树中的每个节点都遵循二叉搜索树的有序性。对于任意节点，其左子树中的值都小于节点的值，而右子树中的值都大于节点的值。

### 操作：

1. **查找：** 从根节点开始，比较要查找的值与当前节点的值，根据比较结果沿着左子树或右子树递归查找。
2. **插入：** 从根节点开始，根据要插入的值的大小，递归地在左子树或右子树中找到合适的位置插入新节点。
3. **删除：** 删除节点时需要考虑不破坏二叉搜索树的有序性。分为三种情况：
   - 如果节点没有子节点，直接删除即可。
   - 如果节点有一个子节点，将其父节点指向子节点。
   - 如果节点有两个子节点，可以选择用其右子树中的最小值节点替换该节点，然后在右子树中删除这个最小值节点。

二叉搜索树的平均时间复杂度为O(log n)，其中n是树中节点的数量。但在最坏情况下，当树高度接近n时，时间复杂度可能退化为O(n)。因此，为了确保平衡性，人们引入了平衡二叉搜索树的概念，例如AVL树和红黑树。这些树在插入和删除节点时保持平衡，提高了查找等操作的性能。

## 2、B-Tree

### 2.1b树的引入

二叉搜索树的最坏情况是退化为一个链表，使时间复杂度变为o（n）

那么我们可以选择不加节点，直接筛数据

![image-20240129182944086](./markdown-img/MySQL索引.assets/image-20240129182944086.png)

但是如果数据塞的过多，可能也会成为一条链表的“尾巴”

![image-20240129183042857](./markdown-img/MySQL索引.assets/image-20240129183042857.png)

于是我们规定一个节点的最多能塞的个数

把超出限制值的这一个节点进行分裂，一般把中间的数据向上分裂

![image-20240129182659248](./markdown-img/MySQL索引.assets/image-20240129182659248.png)



![image-20240129182717290](./markdown-img/MySQL索引.assets/image-20240129182717290.png)

这样就可能导致连锁分裂

以上就是b树

### 2.2b树的正式定义和一些性质

建立一个b树需要指定一个节点最多能包含的节点数量L

上面的例子L=3，称为四阶B树，也叫2-4或2-3-4树，也就是一个节点有2，3，4个节点的树

**b树的一些性质：**

* 所有的叶子节点的深度都相同，都在最底层
* 一个包含n个数据的节点一定有n+1个子节点
* 只有根节点发生分裂时，树的高度才会改变

## 2、b+树

相对于b树

b+树的节点不存储data，只有关键字，data交给叶子节点，叶子节点是一个高度有序的链表





